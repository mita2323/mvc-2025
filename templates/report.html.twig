{% extends "base.html.twig" %}

{% block title %}Report - MVC Course{% endblock %}

{% block body %}
    <main>
        <div class="report-container">
            <h1>Redovisningstexter</h1>

        <nav class="report-link">
            <ul>
                <li><a href="#kmom01">Kmom01</a></li>
                <li><a href="#kmom02">Kmom02</a></li>
                <li><a href="#kmom03">Kmom03</a></li>
                <li><a href="#kmom04">Kmom04</a></li>
                <li><a href="#kmom05">Kmom05</a></li>
                <li><a href="#kmom06">Kmom06</a></li>
                <li><a href="#kmom10">Kmom10</a></li>
            </ul>
        </nav>

            <section id="kmom01">
                <h2>Kmom01</h2>
                <p>
                Mina förkunskaper och tidigare erfarenheter kring objektorientering är från oopython-kursen och lite från JavaScript kursen.
                </p><br>

                <p>
                PHPs modell för klasser och objekt följer en objektorienterad modell som gör det möjligt att strukturera kod på ett organiserat
                och återanvändbart sätt. En klass fungerar som en mall som beskriver hur ett objekt ska se ut och bete sig. När man skapar en
                klass definierar man dess egenskaper (variabler) och metoder (funktioner), som båda beskriver objektets beteende.
                </p><br>

                <p>
                Den kodbas och strukturen som används till uppgiften me/report tycker jag att den är i början lite förvirrade, men man blir snabbt
                bekant med sturkturen och känner igen som från tidigare kurser. Det kommer gå några kursmoment innan jag känner mig helt bekväm
                med denna kursens struktur.
                </p><br>

                <p>
                I artikeln "PHP The Right Way" fanns det två områden som jag tyckte var särskilt intressanta att läsa om: "Language Highlights" och 
                "Dependency Management". Delen "Language Highlights" var intressant eftersom den ger en översikt över PHP:s mest användbara 
                språkfunktioner. Den visar hur man kan skriva kod på olika sätt beroende på vilket problem man försöker lösa. Avsnittet om 
                "Objektorienterad programmering" förklarar hur man kan skapa organiserad, strukturerad och återanvändbar kod. "Funktionell 
                programmering" introducerar nya sätt att arbeta med funktioner, och "Namespaces" hjälper till att organisera koden och 
                förhindrar att klassnamn krockar mellan olika bibliotek.
                </p>
                <p>
                Avsnittet "Dependency Management" var fascinerande att läsa om eftersom det förklarar verktyget Composer. Composer gör det 
                enkelt att hantera externa bibliotek och verktyg som behövs för att koden ska fungera. Med Composer kan man specificera vilka 
                bibliotek ett projekt behöver, och verktyget ser till att rätt version installeras och att alla beroenden laddas in automatiskt
                 när man kör sin applikation. På så sätt slipper man ladda ner och installera bibliotek manuellt, vilket sparar mycket tid och 
                 gör projektet mer hanterbart.
                </p><br>

                <p>
                Min TIL för detta kmom är att jag har lärt mig om ramverket Symfony och hur man bygger en webbplats med den.
                </p>
            </section>

            <section id="kmom02">
                <h2>Kmom02</h2>

                <p>
                I PHP används objektorienterade konstruktioner för att skapa flexibel och återanvändbar kod. <strong>Arv</strong> gör det möjligt för en underklass att
                ärva metoder och egenskaper från en förälderklass, vilket skapar en "är-en"-relation. Till exempel kan en Dog klass ärva från Animal för
                att få en eat()-metod. <strong>Komposition</strong> handlar om att skapa komplexa objekt genom att använda andra objekt som egenskaper, istället för att
                använda arv där klasser byggs upp av andra objekt, vilket ger större flexibilitet. Till exempel när en Order-klass innehåller flera Product-objekt.
                <strong>Interface</strong> är som en regelbok som säger vilka metoder en klass måste ha, med implements, utan att bestämma hur de fungerar, som till exempel
                ett PaymentInterface som kräver att alla betalningsklasser implementerar en processPayment()-metod. <strong>Traits</strong> tillåter återanvändning av 
                kod i flera klasser utan att använda arv, genom att definiera metoder som kan användas av flera klasser. Detta gör att man unviker kod upprepning.
                Tillsammans jobbar som så att arv ochb interface sätter upp regler, komposition gör det enkelt att kombinera objekt, och trait minskar upprepning av kod.
                </p><br>

                <p>
                För denna uppgiften har jag implementerat en kortleksapplikation med PHP och Symfony, den består av flera klasser och kontrollers för att
                hantera en kortlek, dra kort och blanda kortleken. Klassen 'Card' representerar ett enskilt med egenskaperna 'suit' (färg) och 'value' (värde).
                Den innehåller metoder för att hämta dessa värden och konvertera kortet till en läsbar sträng med Unicode-symboler. 'DeckOfCards' hanterar
                en hel kortlek med 52 kort. Den innehåller metoder för att: skapa en ny kortlek, blanda kort, dra kort, sortera korten efter färg och värde, samt
                räkna kvarvarande kort. 'CardGameController' hanterar routerna för kortleks applikationen. 'ApiController' innehåller routes för ett JSON API.
                Den hämtar en sorterad korlek (GET /api/deck), blandar och hämtar kortleken (/POST /api/deck/shuffle), och returnerar strukturerad JSON-svar när man 
                drar ett eller flera kort (POST /api/dek/draw), (POST /api/deck/draw/{number}).
                </p><br>
                <p>
                Jag är nöjd med hur jag löste uppgiften. Laddningssidan för kortleken (/card) blev en bra startpunkt där man kan välja vad man vill göra med kortleken,
                och jag tycker korten såg profsiga ut med Unicode-symbolerna. På API-sidan finns alla tillgängliga JSON routes sammanställd i en tabell. Detta ger en bra överblick över vad som webbplatsen
                erbjuder och gör det enkelt att test olika router. Jag är också nöjd med kod strukturen, vilket gör det lätt att hitta en specifik del av koden.
                Några Förbättringspotential i min kod hade varit att skapa en hjälp metod för att minska kodupprepning.
                </p><br>

                <p>
                Mina reflektioner så här långt med att jobba med Symfony och MVC är att det har varit både lärorikt och kul. Ramverket gör det enkelt
                att strukturera koden med modeller, vyer och kontroller, vilket gör koden mer lättläst och underhållbar. I början kändes det lite överväldigande
                men nu kännes det som att jag förstår mer. 
                </p><br>

                <p>
                Min TIL för detta kmom är att jag har lärt mig att bygga grunderna till ett kortspel samt att jag har tränat på objektorientering och hur
                jag skapar mina egna klasser och applikationer i ramverket Symfony.
                </p>
            </section>

            <section id="kmom03">
                <h2>Kmom03</h2>
                <p>
                    Jag tycker att jobba med flödesdiagram och psuedokod är bra då det tvingar en att fundera och tänka genom hur man vill
                    att koden ska fungera. Man får också en bra visuell representation av spelets logik. Det var dock första gången att jag 
                    har jobbat med psuedokod eller flödesdigram och jag var lite osaker hur de skulle se ut, men jag gjorde mitt bästa och 
                    jag kommer säkert bli bättre på det om jag övar lite på hur man ska rita en bra flödesdigram och skriva bra pusedokod.
                    Flödsdigrammen ritade jag på min ipad och psuedokoden skrev jag i en notepad app på datorn, sedan tog jag en screenshot 
                    på dessa och klistrade in de i dokumentationssidan.
                </p><br>

                <p>
                    I min implementation av kortspelsapplikationen återanvände jag mina Card och DeckOfCards klasser från förra kursmomentet.
                    Min CardGame klass representerar ett enskilt kort i spelet. Den lagrar egenskaper såsom kortets färg och värde. DeckOfCardsGame
                    klassen fungerar som en kortlek och hanterar alla kortrelaterade operationer, den skapar en hel kortlek med 52 kort. Player klassen
                    representerar en spelare i kortspelet, den lagrar spelarens namn och hand. Min Game klass hanterar spelets tillstånd och logik 
                    genom att koordinera interaktioner mellan kortleken och spelarna. CardGameController hanterar användareinteraktioner och
                    sessionstillstånd. Jag är nöjd med hur applikationen fungerar. En Förbättringspotential hade varit att implementera de valfria
                    kraven i uppgiften. Jag måste också bli bättre på att göra flera små commits under tiden jag skriver min kod.
                </p><br>

                <p>
                    Att koda i Symfony känns mycket bättre nu än i början på kursen då jag har fått en bättre förståelse för ramverkets
                    struktur. Det kändes väldigt stort och krångligt i början, men nu när jag har fått jobba med ramverket ett tag känns
                    det väldigt bra.
                </p><br>

                <p>
                    Min TIL för detta kursmoment är att problemlösa innan man börjar med att skriva sin kod, genom att till exempel rita en 
                    flödesdiagram eller skriva psuedokod.
                </p>
            </section>

            <section id="kmom04">
                <h2>Kmom04</h2>
                <p>
                    Jag tyckte att skriva tester var lite av en utmaning, eftersom det kräver att man tänker väldigt noggrant på 
                    hur varje del av koden ska testas. För mig var övningen "Get going with PHPUnit" mycket hjälpsam, och texten 
                    var enkel att följa. Den gjorde det lättare att förstå hur man kommer igång med testskrivning och hur PHPUnit 
                    fungerar. En annan funktion som jag tyckte var mycket användbar var den genererade dokumentationen i 
                    docs/coverage. Här kan man tydligt se vilka rader av koden som har testats, och de rader som inte har 
                    testats markeras i röd färg. Denna översikt var en stor hjälp när jag skrev mina tester, eftersom den gav en 
                    bra visuell indikation på vad som behövde täckas och vad som saknades.
                </p><br>

                <p>
                    Jag lyckades få 100% kodtäckning på alla mina klasser förutom 'Game'. Jag hade som mål att få 100% även där men 
                    jag hann tyvärr inte. Trots det är  jag nöjd att jag lyckades få alla mina klasser över 90% kodtäckning, 
                    vilket känns som ett bra resultat. Jag tycker att min kod består av testbar kod, men det finns definitvt 
                    förbättringsområden för att göra koden mer testbar. Jag valde dock att inte skriva om delar av min kod för att
                    göra den mer testbar.
                </p><br>

                <p>
                    Ja, jag tycker att testbar kod är tecken på "snygg och ren kod". När kod är enkel att testa, brukar den välstrukturerad
                    i mindre delar som är lätta att förstå och ändra. Om koden är svår att testa eller behöver komplicerade lösningar kan '
                    det vara tecken på att designen är för krånglig. Att koden är testbar innebär också att koden är mer lättförståelig och
                    är också lättare att underhålla.
                </p><br>

                <p>
                    Min TIL för detta kursmomentet är att jag lärt mig hur man skriver tester med PHPunit.
                </p>
            </section>

            <section id="kmom05">
                <h2>Kmom05</h2>
                <p>
                    Att arbeta igenom övningen med Symfony och Doctrine gick överlag bra och bra lärorikt. Övningen fokuserade på att 
                    implementera ett bibliotekssystem med CRUD funktionalitet för en Book-entitet. Jag tycker att Doctrine förenklade
                    hanteringen av databasen - genom att definiera Book-entiteten med attribut som 'id', 'title', 'isbn', 'author' och 
                    'imageUrl' blev det enkelt att utföra operationer som att skapa, uppdatera och hämta böcker utan att behöva skriva 
                    rå SQL. Det var också intressant att se hur Symfony och Doctrine integreras och hur man med hjälp av kommandon kan 
                    generera kod och uppdatera databasschemat.
                </p><br>
                
                <p>
                    Min Symfony biblioteksapplikation använder sammanlänkade sidor för att användaren ska kunna intuitivt 
                    navigera med tydliga formulär och navigeringslänkar. Jag har placerat navigeringslänkar strategiskt på 
                    varje sida för att guida användaren genom applikationen. Från landningssidan kan användaren gå vidare 
                    till att skapa en bok. Efter att informationen har fyllts in skickas man automatiskt vidare till listan 
                    med alla böcker. Där kan man klicka på en boktitel för att se all bokinformation. På denna sidan finns 
                    även olika valmöjligheter som att redigera bokinformationen, radera boken, gå tillbaka till alla böcker 
                    eller återvända till landningssidan. Om man väljer att redigera en bok får man dessutom möjligheten att 
                    radera boken. Jag ville att användarupplevelsen skulle kännas smidig, logisk och sammanhängande.
                </p><br>

                <p>
                    Att jobba med ORM i CRUD tyckte jag gick överlag bra. ORM gör det möjligt att arbeta med databasen på ett 
                    objektorienterat sätt, och genom att definiera entiteter i PHP och låta Doctrine hantera kommunikationen med 
                    databasen, slipper man skriva repetitiv SQL-kod. Detta gör att koden blir mer lättläst och underhållbar. Jämfört 
                    med att skriva SQL direkt i applikationen, där man hade behövt skriva och underhålla komplexa querys för varje 
                    CRUD operation, vilket hade tagit mycket mer tid.
                </p><br>

                <p>
                    Min uppfattning om ORM så här långt är att det är ett kraftfullt verktyg för att hantera databaser i objektorienterade 
                    applikationer, särskilt i Symfony. Det underlättar databasoperationer genom att ersätta rå SQL med tydliga och 
                    strukturerade metoder, vilket förbättrar kodens struktur, läsbarhet och underhållbarhet. Jämfört med andra metoder, som 
                    rå SQL, erbjuder Doctrine en mer avancerad och flexibel lösning. För mindre projekt kan det kännas som överarbetat, men 
                    för större applikationer väger fördelarna tyngre och gör det enklare att bygga en välstrukturerad system.
                </p><br>

                <p>
                    Min TIL för detta kursmomentet är att jobba med ORM.
                </p><br>
            </section>

            <section id="kmom06">
                <h2>Kmom06</h2>
                <p>
                    Jag uppfattade PhpMetrics som ett väldigt användbart och kraftfullt verktyg för att utvärdera och förbättra 
                    kodkvalitet i PHP-projekt. Den ger en tydlig överblick över kodens kvalitet genom att visualisera information som 
                    cyklomatisk komplexitet, testtäckning, och underhållbarhet, vilket hjälper att identifiera förbättringsområden.
                </p><br>
                <p>
                    Att integrera mitt projekt med Scrutinizer var lite jobbigt i början då mitt första
                    inspektion fick över 4000 issues och visade väldigt många filer som jag inte kände 
                    igen och som jag inte hade skrivit. Jag lyckades hitta ett lösning på discord efter flera
                    timmars sökning. Det visade sig att /tools foldern var incheckad i scrutinizer och därifrån
                    kom all issues, genom att läga till '/tools' in mit .gitignore fil och sedan commita och pusha
                    kunde jag fixa problemet. Mitt första intryck av Scrutinizer är positiv, det är en kraftful 
                    verktyg för kodanalys och den ger feedback om kodkvalitet. Badges för byggstatus, kodtäckning, 
                    och kodkvalitet är tydliga och ger en snabb överblick över projektets status. Efter första bygget
                    fick jag 14% kodtäckning och 9.96 kodkvalitet.
                </p><br>
                <p>
                    Min syn på kodkvalitet är att det är en viktig del av att skriva förståelig, testbar och underhållbar kod.
                    Jag tycker att badges, till exempel för testtäckning eller kodstil, kan ge en viss indikation på 
                    kodens kvalitet, men de visar inte hela bilden. Därför tycker jag att badges ska användas mer som ett stöd 
                    istället för ett definitivt mått på hur bra koden är.
                </p><br>
                <p>
                    Min TIL för detta kursmomentet är att använda verktygen PHPMetrics för att 
                    att få en visualisering av kodens komplexitet och underhållbarhet, samt 
                    Scrutinizer för att identifiera och åtgärda specifik kodproblem.
                </p>
            </section>

            <section id="kmom10">
                <h2>Kmom10</h2>
                <p>
                    Jag har skapat en landningssida /proj som syns i navbaren på min report-sida. Trycker man på ’Projekt’ länken kommer 
                    man till mitt projekt sida som har en stil och utseende som skiljer sig tydligt från min report-sida och har en separat 
                    navbar för projektet. Min ’About’ sida innehåller information om projektet och vad det handlar om.
                </p><br>
                <p>
                    För detta projekt har jag valt att bygga vidare på mitt Black Jack spel från tidigare kursmoment. Spelet börjar 
                    med att spelaren skriver in sitt namn och sedan kan spelaren välja att spela mellan 1 och 3 händer samtidigt mot banken. 
                    Sedan går man vidare till satsningsfasen, där spelaren väljer hur mycket de vill satsa per hand, summan måste vara minst 
                    10 kr och högst deras saldo. Efter att insatsen skickats startar spelet genom att kort delar ut, och spelaren 
                    omdirigeras till huvudspelets gränssnitt. Play.html.twig mallen ansvarar för att visa och hantera spelets huvudsakliga 
                    gränssnitt. Den renderar spelarens och dealerns händer, visar spelresultat, erbjuder handlingsalternativ som att ta kort,
                    eller stanna. Under pågående spel (status == ’ongoing’) visas spelarens händer med poäng, insatser och villkorliga
                    knappar, medan dealerns hand delvis är dold. När spelet avslutas visas resultat och via JavaScript, animeras dealerns
                    kort med poänguppdatering. Om spelarens saldo når noll, då visas ett meddelande att spelet är slut, annars omdirigeras
                    spelaren till satsningssidan efter en 10-sekunders nedräkning. 
                </p><br>
                <p>
                    Min ProjectController.php hanterar alla flöden kring spelet Blackjack och använder rutter för att styra olika delar av 
                    spelet, som startsida, regler, satsning, spelhandlingar (ta kort, stanna, dubbla, splitta) och återställning. 
                    Kontrollen injicerar EntityManagerInterface för att hantera spelarens saldo i databasen och använder sessioner för 
                    att spara spelarens namn, antal händer och speltillstånd. Funktionen ’reset’ återställer spelarens saldo till 1000 
                    i databasen och rensar sessionen. Varje metod renderar den relevanta Twig-mallen och inkluderar felhantering.
                </p><br>
                <p>
                   BlackJackDeck.php definierar klassen BlackJackDeck, som hanterar en 52-kortslek för BlackJack. Kort representeras av 
                   BlackJackGraphic-objekt. Klassen skapar leken i konstruktorn genom att kombinera fyra färger och 13 värden. Den 
                   innehåller metoder för att hämta (getCards), blanda (shuffle), dra (draw) och ersätta (setCards) kortleken.
                </p><br>
                <p>
                    BlackJackGraphic.php innehåller klassen BlackJackGraphic, som representerar ett spelkort i Blackjack. Den lagrar färg och 
                    värde, beräknar kortet poäng, och erbjuder metoden för att hämta rank, färg, unicode-symbol, strängrepresentation samt 
                    JSON-data visa JSONSerializable.
                </p><br>
                <p>
                    BlackJackPlayer.php definierar klassen BlackJackPlayer och hanterar en spelares eller dealers tillstånd i Blackjack. Den
                    lagrar namn, händer, insatser, handstatusar och eventuell databasentitet för saldo. Klassen innehåller metoder för att 
                    lägga till kort, hantera insatser och vinster, samt räkna poäng med hänsyns till ess. Den stödjer även handlingar som 
                    split, stand, och bust, samt kontroller för blackjack. Klassen används för både spelare och dealer, och är en viktig 
                    del av spelets logik. 
                </p><br>
                <p>
                    BlackJack.php innehåller klassen BlackJack, som hanterar logiken för Blackjack spelet. Klassen initierar ett spel med en 
                    blandad kortlek (BlackJackDeck), en spelare och en dealer (BlackJackPlayer), samt spårar speltillstånd och spelarens 
                    saldo. Metoden ’startGame’ validerar insats och antal händer, delar ut kort och sätter spelets status. Spelaren kan sedan 
                    utföra handlingar som hit, stand, doubleDown och split, som påverkar handen och turordningen. Dealerns tur styrs av 
                    ’playDealer’, som drar kort tills minst 17 uppnås. Spelet utvärderas i ’evaluateGame’, där resultat jämförs och spelarens 
                    saldo uppdateras. För att spara och återställa spelet används metoderna ’getState’ och ’reset’, vilket möjliggör 
                    sessionsbaserat spel. Metoder som ’getPlayer’, ’getDealer’ och ’getStatus’ ger åtkomst till spelets aktuella data. 
                    BlackJack fungerar som hjärtat i applikationen och binder samman spelregler, användardata och gränssnitt.  
                </p><br>
                <p>
                    I min Entity folder har jag mina Entity filer, CardStat.php som lagrar statistik om hur ofta varje kortvärden har 
                    dragits i spelet, GameSession.php som representerar en enskild spelomgång för en spelare, och Player.php som 
                    representerar en spelare i systemet.
                </p><br>
                <p>
                    I Repository finns mina tre repository-klasserna som tillhör projektet. CardStatRepository.php hanterar databasfrågor 
                    för CardStat-entiteten, GameSessionRepository.php som hanterar alla databasoperationer relaterade till 
                    GameSession-entiteten, och PlayerRepository.php som sköter databasanrop relaterade till Player-entiteten.
                </p><br>
                <p>
                    I templates/project ligger alla mina Twig mallar, och i tests/Project har jag alla mina tester till detta projekt. 
                </p><br>
                <p>
                    I mitt README.md fil finns scrutinizer badges som är klickbara, instruktion för hur man klonar och startar igång 
                    webbplatsen, samt en kort beskrivning om innehållet av report.
                </p><br>
                <p>
                    För mitt Blackjack projekt har mina tester nästan 100% kodtäckning. Att den inte är 100% beror på att jag inte hann 
                    skriva alla tester för BlackJack klassen. Enligt PHP metrics är min genomsnittlig cyklomatisk komplexitet per klass 
                    lite hög, och detta beror på tre klasser: BlackJackPlayer, ProjectController och BlackJack. Dessa filer är för stora 
                    och för komplexa. I scrutinizer har min kod fått betyget 8.88 och detta beror på de samma tre filer. För att förbättra 
                    scrutinizer betygen och förbättra underhållbarheten och komplexiteten skulle det vara bra att dela upp dessa stora och 
                    långa filer till mindre filer som är lättare att underhålla. 
                </p><br>
                <p>
                   Själva blackjack spelet tyckte jag var lärorikt och roligt att bygga vidare på och utveckla. Det tog en rimlig lång tid 
                   att genomföra själva spelet, dock fick jag spendera mycket tid på att skriva tester som passerade med composer phpunit 
                   för projektet. Eftersom jag har ganska mycket kod, fick jag skriva väldigt många olika tester, och jag fick många 
                   felmeddelanden som jag behövde felsöka och fixa. Ett annat moment som tog länge var att fixa till alla issues i 
                   phpmetrics och alla errors och failures i composer lint. Ett problem som jag stötte på var efter att jag hade genererat 
                   metrics för min kod, upptäckte jag att jag hade tre filer som hade dåliga underhållbarhet och för hög komplexitet. 
                   Jag ville försöka fixa detta men eftersom jag hade redan skrivit tester för dessa filer, gick det inte bra att försöka 
                   dela upp dem då jag fick väldigt många felmeddelanden. Hade jag haft mer tid, hade jag säkert kunnat förbättra dessa 
                   tre filer. 
                </p><br>
                <p>
                    Jag tycker att projektet inte var för lätt eller för svår, och tog en rimlig tid att genomföra. Detta projekt var 
                    ett bra och rimligt projekt för denna kurs.
                </p><br>
                <p>
                    Mina tankar om kursen är att kursmomenten är väl uppdelad, och övningarna hjälper till att förbereda innan man arbetar
                    med uppgiften för kursmomentet. På dbwebb.se finns det en 'läs & studera' del som innehåller föreläsningar och litteratur
                    vilket jag tycker är mycket hjälpsam, samt alla föreläsningar som finns på youtube. Discord är ett väldigt bra verktyg då
                    man kan ställa frågor eller söka genom andra elevers lösningar till felmeddelanden eller error som man själv får. Kursen
                    hade bra storlek på övningar och uppgifter till varje kursmoment, vilket är bra då man hinner man den andra kursen webapp,
                    och inte ligger efter. Lärarna ger bra feedback för varje inlämnad uppgift. Jag är nöjd med kursen och skulle rekommendera
                    den till mina vänner/kollegor. På en skala av 1-10 skulle jag ge kursen en 9.
                </p>
            </section>
        </div>
    </main>
{% endblock %}