{% extends "base.html.twig" %}

{% block title %}Report - MVC Course{% endblock %}

{% block body %}
    <main>
        <div class="report-container">
            <h1>Redovisningstexter</h1>

        <nav class="report-link">
            <ul>
                <li><a href="#kmom01">Kmom01</a></li>
                <li><a href="#kmom02">Kmom02</a></li>
                <li><a href="#kmom03">Kmom03</a></li>
                <li><a href="#kmom04">Kmom04</a></li>
                <li><a href="#kmom05">Kmom05</a></li>
                <li><a href="#kmom06">Kmom06</a></li>
                <li><a href="#kmom10">Kmom10</a></li>
            </ul>
        </nav>

            <section id="kmom01">
                <h2>Kmom01</h2>
                <p>
                Mina förkunskaper och tidigare erfarenheter kring objektorientering är från oopython-kursen och lite från JavaScript kursen.
                </p><br>

                <p>
                PHPs modell för klasser och objekt följer en objektorienterad modell som gör det möjligt att strukturera kod på ett organiserat
                och återanvändbart sätt. En klass fungerar som en mall som beskriver hur ett objekt ska se ut och bete sig. När man skapar en
                klass definierar man dess egenskaper (variabler) och metoder (funktioner), som båda beskriver objektets beteende.
                </p><br>

                <p>
                Den kodbas och strukturen som används till uppgiften me/report tycker jag att den är i början lite förvirrade, men man blir snabbt
                bekant med sturkturen och känner igen som från tidigare kurser. Det kommer gå några kursmoment innan jag känner mig helt bekväm
                med denna kursens struktur.
                </p><br>

                <p>
                I artikeln "PHP The Right Way" fanns det två områden som jag tyckte var särskilt intressanta att läsa om: "Language Highlights" och 
                "Dependency Management". Delen "Language Highlights" var intressant eftersom den ger en översikt över PHP:s mest användbara 
                språkfunktioner. Den visar hur man kan skriva kod på olika sätt beroende på vilket problem man försöker lösa. Avsnittet om 
                "Objektorienterad programmering" förklarar hur man kan skapa organiserad, strukturerad och återanvändbar kod. "Funktionell 
                programmering" introducerar nya sätt att arbeta med funktioner, och "Namespaces" hjälper till att organisera koden och 
                förhindrar att klassnamn krockar mellan olika bibliotek.
                </p>
                <p>
                Avsnittet "Dependency Management" var fascinerande att läsa om eftersom det förklarar verktyget Composer. Composer gör det 
                enkelt att hantera externa bibliotek och verktyg som behövs för att koden ska fungera. Med Composer kan man specificera vilka 
                bibliotek ett projekt behöver, och verktyget ser till att rätt version installeras och att alla beroenden laddas in automatiskt
                 när man kör sin applikation. På så sätt slipper man ladda ner och installera bibliotek manuellt, vilket sparar mycket tid och 
                 gör projektet mer hanterbart.
                </p><br>

                <p>
                Min TIL för detta kmom är att jag har lärt mig om ramverket Symfony och hur man bygger en webbplats med den.
                </p>
            </section>

            <section id="kmom02">
                <h2>Kmom02</h2>

                <p>
                I PHP används objektorienterade konstruktioner för att skapa flexibel och återanvändbar kod. <strong>Arv</strong> gör det möjligt för en underklass att
                ärva metoder och egenskaper från en förälderklass, vilket skapar en "är-en"-relation. Till exempel kan en Dog klass ärva från Animal för
                att få en eat()-metod. <strong>Komposition</strong> handlar om att skapa komplexa objekt genom att använda andra objekt som egenskaper, istället för att
                använda arv där klasser byggs upp av andra objekt, vilket ger större flexibilitet. Till exempel när en Order-klass innehåller flera Product-objekt.
                <strong>Interface</strong> är som en regelbok som säger vilka metoder en klass måste ha, med implements, utan att bestämma hur de fungerar, som till exempel
                ett PaymentInterface som kräver att alla betalningsklasser implementerar en processPayment()-metod. <strong>Traits</strong> tillåter återanvändning av 
                kod i flera klasser utan att använda arv, genom att definiera metoder som kan användas av flera klasser. Detta gör att man unviker kod upprepning.
                Tillsammans jobbar som så att arv ochb interface sätter upp regler, komposition gör det enkelt att kombinera objekt, och trait minskar upprepning av kod.
                </p><br>

                <p>
                För denna uppgiften har jag implementerat en kortleksapplikation med PHP och Symfony, den består av flera klasser och kontrollers för att
                hantera en kortlek, dra kort och blanda kortleken. Klassen 'Card' representerar ett enskilt med egenskaperna 'suit' (färg) och 'value' (värde).
                Den innehåller metoder för att hämta dessa värden och konvertera kortet till en läsbar sträng med Unicode-symboler. 'DeckOfCards' hanterar
                en hel kortlek med 52 kort. Den innehåller metoder för att: skapa en ny kortlek, blanda kort, dra kort, sortera korten efter färg och värde, samt
                räkna kvarvarande kort. 'CardGameController' hanterar routerna för kortleks applikationen. 'ApiController' innehåller routes för ett JSON API.
                Den hämtar en sorterad korlek (GET /api/deck), blandar och hämtar kortleken (/POST /api/deck/shuffle), och returnerar strukturerad JSON-svar när man 
                drar ett eller flera kort (POST /api/dek/draw), (POST /api/deck/draw/{number}).
                </p><br>
                <p>
                Jag är nöjd med hur jag löste uppgiften. Laddningssidan för kortleken (/card) blev en bra startpunkt där man kan välja vad man vill göra med kortleken,
                och jag tycker korten såg profsiga ut med Unicode-symbolerna. På API-sidan finns alla tillgängliga JSON routes sammanställd i en tabell. Detta ger en bra överblick över vad som webbplatsen
                erbjuder och gör det enkelt att test olika router. Jag är också nöjd med kod strukturen, vilket gör det lätt att hitta en specifik del av koden.
                Några Förbättringspotential i min kod hade varit att skapa en hjälp metod för att minska kodupprepning.
                </p><br>

                <p>
                Mina reflektioner så här långt med att jobba med Symfony och MVC är att det har varit både lärorikt och kul. Ramverket gör det enkelt
                att strukturera koden med modeller, vyer och kontroller, vilket gör koden mer lättläst och underhållbar. I början kändes det lite överväldigande
                men nu kännes det som att jag förstår mer. 
                </p><br>

                <p>
                Min TIL för detta kmom är att jag har lärt mig att bygga grunderna till ett kortspel samt att jag har tränat på objektorientering och hur
                jag skapar mina egna klasser och applikationer i ramverket Symfony.
                </p>
            </section>

            <section id="kmom03">
                <h2>Kmom03</h2>
                <p>
                    Jag tycker att jobba med flödesdiagram och psuedokod är bra då det tvingar en att fundera och tänka genom hur man vill
                    att koden ska fungera. Man får också en bra visuell representation av spelets logik. Det var dock första gången att jag 
                    har jobbat med psuedokod eller flödesdigram och jag var lite osaker hur de skulle se ut, men jag gjorde mitt bästa och 
                    jag kommer säkert bli bättre på det om jag övar lite på hur man ska rita en bra flödesdigram och skriva bra pusedokod.
                    Flödsdigrammen ritade jag på min ipad och psuedokoden skrev jag i en notepad app på datorn, sedan tog jag en screenshot 
                    på dessa och klistrade in de i dokumentationssidan.
                </p><br>

                <p>
                    I min implementation av kortspelsapplikationen återanvände jag mina Card och DeckOfCards klasser från förra kursmomentet.
                    Min CardGame klass representerar ett enskilt kort i spelet. Den lagrar egenskaper såsom kortets färg och värde. DeckOfCardsGame
                    klassen fungerar som en kortlek och hanterar alla kortrelaterade operationer, den skapar en hel kortlek med 52 kort. Player klassen
                    representerar en spelare i kortspelet, den lagrar spelarens namn och hand. Min Game klass hanterar spelets tillstånd och logik 
                    genom att koordinera interaktioner mellan kortleken och spelarna. CardGameController hanterar användareinteraktioner och
                    sessionstillstånd. Jag är nöjd med hur applikationen fungerar. En Förbättringspotential hade varit att implementera de valfria
                    kraven i uppgiften. Jag måste också bli bättre på att göra flera små commits under tiden jag skriver min kod.
                </p><br>

                <p>
                    Att koda i Symfony känns mycket bättre nu än i början på kursen då jag har fått en bättre förståelse för ramverkets
                    struktur. Det kändes väldigt stort och krångligt i början, men nu när jag har fått jobba med ramverket ett tag känns
                    det väldigt bra.
                </p><br>

                <p>
                    Min TIL för detta kursmoment är att problemlösa innan man börjar med att skriva sin kod, genom att till exempel rita en 
                    flödesdiagram eller skriva psuedokod.
                </p>
            </section>

            <section id="kmom04">
                <h2>Kmom04</h2>
                <p>
                    Jag tyckte att skriva tester var lite av en utmaning, eftersom det kräver att man tänker väldigt noggrant på 
                    hur varje del av koden ska testas. För mig var övningen "Get going with PHPUnit" mycket hjälpsam, och texten 
                    var enkel att följa. Den gjorde det lättare att förstå hur man kommer igång med testskrivning och hur PHPUnit 
                    fungerar. En annan funktion som jag tyckte var mycket användbar var den genererade dokumentationen i 
                    docs/coverage. Här kan man tydligt se vilka rader av koden som har testats, och de rader som inte har 
                    testats markeras i röd färg. Denna översikt var en stor hjälp när jag skrev mina tester, eftersom den gav en 
                    bra visuell indikation på vad som behövde täckas och vad som saknades.
                </p><br>

                <p>
                    Jag lyckades få 100% kodtäckning på alla mina klasser förutom 'Game'. Jag hade som mål att få 100% även där men 
                    jag hann tyvärr inte. Trots det är  jag nöjd att jag lyckades få alla mina klasser över 90% kodtäckning, 
                    vilket känns som ett bra resultat. Jag tycker att min kod består av testbar kod, men det finns definitvt 
                    förbättringsområden för att göra koden mer testbar. Jag valde dock att inte skriva om delar av min kod för att
                    göra den mer testbar.
                </p><br>

                <p>
                    Ja, jag tycker att testbar kod är tecken på "snygg och ren kod". När kod är enkel att testa, brukar den välstrukturerad
                    i mindre delar som är lätta att förstå och ändra. Om koden är svår att testa eller behöver komplicerade lösningar kan '
                    det vara tecken på att designen är för krånglig. Att koden är testbar innebär också att koden är mer lättförståelig och
                    är också lättare att underhålla.
                </p><br>

                <p>
                    Min TIL för detta kursmomentet är att jag lärt mig hur man skriver tester med PHPunit.
                </p>
            </section>

            <section id="kmom05">
                <h2>Kmom05</h2>
                <p>
                    Att arbeta igenom övningen med Symfony och Doctrine gick överlag bra och bra lärorikt. Övningen fokuserade på att 
                    implementera ett bibliotekssystem med CRUD funktionalitet för en Book-entitet. Jag tycker att Doctrine förenklade
                    hanteringen av databasen - genom att definiera Book-entiteten med attribut som 'id', 'title', 'isbn', 'author' och 
                    'imageUrl' blev det enkelt att utföra operationer som att skapa, uppdatera och hämta böcker utan att behöva skriva 
                    rå SQL. Det var också intressant att se hur Symfony och Doctrine integreras och hur man med hjälp av kommandon kan 
                    generera kod och uppdatera databasschemat.
                </p><br>
                
                <p>
                    Min Symfony biblioteksapplikation använder sammanlänkade sidor för att användaren ska kunna intuitivt 
                    navigera med tydliga formulär och navigeringslänkar. Jag har placerat navigeringslänkar strategiskt på 
                    varje sida för att guida användaren genom applikationen. Från landningssidan kan användaren gå vidare 
                    till att skapa en bok. Efter att informationen har fyllts in skickas man automatiskt vidare till listan 
                    med alla böcker. Där kan man klicka på en boktitel för att se all bokinformation. På denna sidan finns 
                    även olika valmöjligheter som att redigera bokinformationen, radera boken, gå tillbaka till alla böcker 
                    eller återvända till landningssidan. Om man väljer att redigera en bok får man dessutom möjligheten att 
                    radera boken. Jag ville att användarupplevelsen skulle kännas smidig, logisk och sammanhängande.
                </p><br>

                <p>
                    Att jobba med ORM i CRUD tyckte jag gick överlag bra. ORM gör det möjligt att arbeta med databasen på ett 
                    objektorienterat sätt, och genom att definiera entiteter i PHP och låta Doctrine hantera kommunikationen med 
                    databasen, slipper man skriva repetitiv SQL-kod. Detta gör att koden blir mer lättläst och underhållbar. Jämfört 
                    med att skriva SQL direkt i applikationen, där man hade behövt skriva och underhålla komplexa querys för varje 
                    CRUD operation, vilket hade tagit mycket mer tid.
                </p><br>

                <p>
                    Min uppfattning om ORM så här långt är att det är ett kraftfullt verktyg för att hantera databaser i objektorienterade 
                    applikationer, särskilt i Symfony. Det underlättar databasoperationer genom att ersätta rå SQL med tydliga och 
                    strukturerade metoder, vilket förbättrar kodens struktur, läsbarhet och underhållbarhet. Jämfört med andra metoder, som 
                    rå SQL, erbjuder Doctrine en mer avancerad och flexibel lösning. För mindre projekt kan det kännas som överarbetat, men 
                    för större applikationer väger fördelarna tyngre och gör det enklare att bygga en välstrukturerad system.
                </p><br>

                <p>
                    Min TIL för detta kursmomentet är att jobba med ORM.
                </p><br>
            </section>

            <section id="kmom06">
                <h2>Kmom06</h2>
                <p>
                    Jag uppfattade PhpMetrics som ett väldigt användbart och kraftfullt verktyg för att utvärdera och förbättra 
                    kodkvalitet i PHP-projekt. Den ger en tydlig överblick över kodens kvalitet genom att visualisera information som 
                    cyklomatisk komplexitet, testtäckning, och underhållbarhet, vilket hjälper att identifiera förbättringsområden.
                </p><br>
                <p>
                    Att integrera mitt projekt med Scrutinizer var lite jobbigt i början då mitt första
                    inspektion fick över 4000 issues och visade väldigt många filer som jag inte kände 
                    igen och som jag inte hade skrivit. Jag lyckades hitta ett lösning på discord efter flera
                    timmars sökning. Det visade sig att /tools foldern var incheckad i scrutinizer och därifrån
                    kom all issues, genom att läga till '/tools' in mit .gitignore fil och sedan commita och pusha
                    kunde jag fixa problemet. Mitt första intryck av Scrutinizer är positiv, det är en kraftful 
                    verktyg för kodanalys och den ger feedback om kodkvalitet. Badges för byggstatus, kodtäckning, 
                    och kodkvalitet är tydliga och ger en snabb överblick över projektets status. Efter första bygget
                    fick jag 14% kodtäckning och 9.96 kodkvalitet.
                </p><br>
                <p>
                    Min syn på kodkvalitet är att det är en viktig del av att skriva förståelig, testbar och underhållbar kod.
                    Jag tycker att badges, till exempel för testtäckning eller kodstil, kan ge en viss indikation på 
                    kodens kvalitet, men de visar inte hela bilden. Därför tycker jag att badges ska användas mer som ett stöd 
                    istället för ett definitivt mått på hur bra koden är.
                </p><br>
                <p>
                    Min TIL för detta kursmomentet är att använda verktygen PHPMetrics för att 
                    att få en visualisering av kodens komplexitet och underhållbarhet, samt 
                    Scrutinizer för att identifiera och åtgärda specifik kodproblem.
                </p>
            </section>

            <section id="kmom10">
                <h2>Kmom10</h2>
                <p>
                    Redovisningstext för kmom10
                </p>
            </section>
        </div>
    </main>
{% endblock %}